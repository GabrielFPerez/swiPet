{"ast":null,"code":"const bcrypt = require('bcrypt');\nconst {\n  ObjectId\n} = require('mongodb');\nrequire('mongodb');\nrequire('express');\nexports.setApp = function (app, client) {\n  // Put database name here, so can use to specify\n  // database to be used\n  const dbName = 'swiPet';\n\n  // Modified login api\n  app.post('/api/login', async (req, res, next) => {\n    // incoming: login, password\n    // outgoing: id, firstName, lastName, error\n\n    // Need to initialize ret outside of\n    // conditional statements...\n    let ret = {};\n    let message = '';\n    const {\n      login,\n      password\n    } = req.body;\n\n    // Same dbName here\n    const db = client.db(dbName);\n    const user = await db.collection('User').findOne({\n      Login: login\n    });\n\n    // A user's login is found\n    if (user) {\n      const passwordMatch = await bcrypt.compare(password, user.Password);\n\n      // Password matches\n      if (passwordMatch) {\n        ret = {\n          id: user._id,\n          firstName: user.FirstName,\n          lastName: user.LastName,\n          message: message\n        };\n      }\n\n      // Password doesn't match\n      else {\n        message = \"Invalid credentials\";\n        ret = {\n          message: message\n        };\n      }\n    }\n    // User's login not found\n    else {\n      message = \"User not found\";\n      ret = {\n        message: message\n      };\n    }\n    res.status(200).json(ret);\n  });\n\n  // Delete user api; should delete user from database...\n  app.post(\"/api/deleteUser\", async (req, res, next) => {\n    // incoming: login, password\n    // outgoing: message\n\n    let message = \"\";\n    const {\n      login,\n      password\n    } = req.body;\n    const db = client.db(dbName);\n    try {\n      // Search for user\n      // Since hashing password, search for login only\n      // password will be checked later\n      const user = await db.collection(\"User\").findOne({\n        Login: login\n      });\n\n      // If user is found... cast delete user!\n      if (user) {\n        // Compare password and hashed password in database\n        const passwordMatch = bcrypt.compare(password, user.Password);\n\n        // If passwords match... cast delete\n        if (passwordMatch) {\n          const result = db.collection(\"User\").deleteOne({\n            _id: user._id\n          });\n          message = \"User deleted\";\n        } else {\n          message = \"Incorrect credentials\";\n        }\n      } else {\n        message = \"User not found\";\n      }\n    } catch (e) {\n      message = e.toString();\n    }\n    let ret = {\n      message: message\n    };\n    res.status(200).json(ret);\n  });\n\n  // Update user api - not including password\n  app.post(\"/api/updateUser\", async (req, res, next) => {\n    // incoming: login, firstName, lastName, email, phoneNumber, location\n    // outgoing: (new/same - firstName, lastName, email, phoneNumber, location), message\n    const {\n      login,\n      firstName,\n      lastName,\n      email,\n      phoneNumber,\n      location\n    } = req.body;\n    let message = '';\n    const db = client.db(dbName);\n    const collection = db.collection('User');\n    let user = await collection.findOne({\n      Login: login\n    });\n\n    // Check to see if valid user\n    if (user) {\n      let updatedUser = {\n        FirstName: firstName,\n        LastName: lastName,\n        Email: email,\n        PhoneNumber: phoneNumber,\n        Location: location\n      };\n\n      // Trim empty fields from updatedUser\n      // Done by stringify, which does not stringify\n      // undefined data, and parsing back to json\n      updatedUser = JSON.parse(JSON.stringify(updatedUser));\n      try {\n        // updateOne (filter, update)\n        // Filter based off login\n        const result = await collection.updateOne(\n        // Case sensitive; Login: login,\n        // not login: login\n        {\n          Login: login\n        }, {\n          $set: updatedUser\n        });\n\n        // Check to see if anything was updated\n        if (result.modifiedCount === 0) {\n          message = \"No changes made to user\";\n        } else {\n          message = \"User updated successfully\";\n        }\n      } catch (e) {\n        message = e.toString();\n      }\n    } else {\n      message = \"User not found\";\n    }\n    let ret = {\n      message: message\n    };\n    res.status(200).json(ret);\n  });\n\n  // Forgot password api\n  app.post(\"/api/forgotPassword\", async (req, res, next) => {});\n\n  // Register api\n  // Need to implement password hashing via bcrypt - to do\n  app.post(\"/api/register\", async (req, res, next) => {\n    // incoming: firstName, lastName, login, password\n    // outgoing: id, firstName, lastName, email, message\n    const {\n      firstName,\n      lastName,\n      email,\n      phoneNumber,\n      location,\n      login,\n      password\n    } = req.body;\n    let message = '';\n    let id = -1;\n\n    // Forgot to add connection...\n    const db = client.db(dbName);\n\n    // try-catch to see if user exists or not\n    // if not, make new user\n    try {\n      // findOne finds one instance, which there should only be one\n      // instance of a login anyways\n      const existingUser = await db.collection('User').findOne({\n        Login: login\n      });\n\n      // If user is found, don't do anything\n      if (existingUser) {\n        message = \"User already exists...\";\n      } else {\n        //== bCrypt stuff... ==\n        // Essentially determines how long is spent\n        // on hashing password; higher is better, but\n        // takes longer to hash\n        const saltRounds = 12;\n        // Hash call\n        const hashedPassword = await bcrypt.hash(password, saltRounds);\n        //== End of bCrypt stuff... ==\n\n        // No user with login found, so make new user\n        const newUser = {\n          FirstName: firstName,\n          LastName: lastName,\n          Email: email,\n          PhoneNumber: phoneNumber,\n          Location: location,\n          Login: login,\n          Password: hashedPassword,\n          Favorites: {},\n          Listings: {}\n        };\n        const result = await db.collection('User').insertOne(newUser);\n        id = result.insertedId;\n      }\n    } catch (e) {\n      message = e.toString();\n    }\n\n    // probably dont want  to return login and password here...\n    let ret = {\n      id: id,\n      firstName: firstName,\n      lastName: lastName,\n      email: email,\n      message: message\n    };\n    res.status(200).json(ret);\n  });\n\n  // API to add new pets to specific users and update their listings to reflect the new pet\n  app.post('/api/addpet', async (req, res) => {\n    // incoming: userLogin, petName, type, petAge, petGender, breed, petSize, bio, contactEmail, location, images\n    // outgoing: message, petId\n\n    const {\n      userLogin,\n      petName,\n      type,\n      petAge,\n      petGender,\n      breed,\n      petSize,\n      bio,\n      contactEmail,\n      location,\n      images\n    } = req.body;\n    let message = '';\n    let petId = null;\n    try {\n      // Connect to database\n      const db = client.db(dbName);\n\n      // Checks if there is a valid user to create the pet, if there is then create the pet\n      const user = await db.collection('User').findOne({\n        Login: userLogin\n      });\n      if (user) {\n        const newPet = {\n          Login: userLogin,\n          Pet_Name: petName,\n          Pet_Type: type,\n          Age: petAge,\n          Gender: petGender,\n          Breed: breed,\n          Size: petSize,\n          Bio: bio,\n          Contact_Email: contactEmail,\n          Location: location,\n          Images: images || []\n        };\n        // Insert new pet and their descriptions into database\n        const result = await db.collection('Pet').insertOne(newPet);\n\n        // Needed to get the pet's ObjectId\n        petId = result.insertedId;\n\n        // Updates Listing of user who created the pet with the pet's ObjectId\n        await db.collection('User').updateOne({\n          Login: userLogin\n        }, {\n          $push: {\n            Listings: petId\n          }\n        });\n        message = \"Pet Created\";\n      } else {\n        message = \"User does not exist\";\n      }\n    } catch (e) {\n      message = e.toString();\n    }\n    const ret = {\n      message: message,\n      petId: petId\n    };\n    res.status(200).json(ret);\n  });\n\n  // API to add a pet to a user's favorites list\n  app.post('/api/addfavorite', async (req, res) => {\n    // incoming: userLogin, petId\n    // outgoing: message\n\n    const {\n      userLogin,\n      petId\n    } = req.body;\n    let message = '';\n    try {\n      // Connect to the database\n      const db = client.db(dbName);\n\n      // Checks if there is a valid user\n      const user = await db.collection('User').findOne({\n        Login: userLogin\n      });\n      if (user) {\n        const objectId = new ObjectId(petId);\n\n        // Check if there is a valid pet as well\n        const pet = await db.collection('Pet').findOne({\n          _id: objectId\n        });\n\n        // If there is a valid user and a valid pet, add that pet to the user's favorited pets\n        if (pet) {\n          await db.collection('User').updateOne({\n            Login: userLogin\n          }, {\n            $addToSet: {\n              Favorites: objectId\n            }\n          });\n          message = \"Pet added to favorites\";\n        } else {\n          message = \"Pet not found\";\n        }\n      } else {\n        message = \"User does not exist\";\n      }\n    } catch (e) {\n      message = e.toString();\n    }\n    const ret = {\n      message: message\n    };\n    res.status(200).json(ret);\n  });\n\n  // API to delete a pet and the listing of the original user who uploaded the pet (as well as from the favorites list of anyone who has that pet favorited)\n  app.post('/api/deletepet', async (req, res) => {\n    // incoming: userLogin, petId\n    // outgoing: message\n\n    const {\n      userLogin,\n      petId\n    } = req.body;\n    let message = '';\n    try {\n      // Connect to database\n      const db = client.db(dbName);\n      const user = await db.collection('User').findOne({\n        Login: userLogin\n      });\n\n      // If there is a valid user, proceed to see if the pet is in the database\n      if (user) {\n        const objectId = new ObjectId(petId);\n        const pet = await db.collection('Pet').findOne({\n          _id: objectId\n        });\n\n        // If the pet is in the database, proceed with deletion\n        if (pet) {\n          // If the user that created the pet does not matche with the user that was inputted, return error\n          if (pet.Login !== userLogin) {\n            message = \"You do not have permission to delete this pet\";\n          } else {\n            // Delete from the pet collection\n            await db.collection('Pet').deleteOne({\n              _id: pet._id\n            });\n\n            // Update the creator's listings to remove it\n            await db.collection('User').updateOne({\n              Login: userLogin\n            }, {\n              $pull: {\n                Listings: pet._id\n              }\n            });\n\n            // Update all favorite's lists in all users so that it reflects that the pet was deleted\n            await db.collection('User').updateMany({\n              Favorites: pet._id\n            }, {\n              $pull: {\n                Favorites: pet._id\n              }\n            });\n            message = \"Pet deleted successfully and removed from all favorites\";\n          }\n        } else {\n          message = \"Pet not found\";\n        }\n      } else {\n        message = \"User does not exist\";\n      }\n    } catch (e) {\n      message = e.toString();\n    }\n    const ret = {\n      message: message\n    };\n    res.status(200).json(ret);\n  });\n};","map":{"version":3,"names":["bcrypt","require","ObjectId","exports","setApp","app","client","dbName","post","req","res","next","ret","message","login","password","body","db","user","collection","findOne","Login","passwordMatch","compare","Password","id","_id","firstName","FirstName","lastName","LastName","status","json","result","deleteOne","e","toString","email","phoneNumber","location","updatedUser","Email","PhoneNumber","Location","JSON","parse","stringify","updateOne","$set","modifiedCount","existingUser","saltRounds","hashedPassword","hash","newUser","Favorites","Listings","insertOne","insertedId","userLogin","petName","type","petAge","petGender","breed","petSize","bio","contactEmail","images","petId","newPet","Pet_Name","Pet_Type","Age","Gender","Breed","Size","Bio","Contact_Email","Images","$push","objectId","pet","$addToSet","$pull","updateMany"],"sources":["/Users/lukesandoval/Library/CloudStorage/OneDrive-UniversityofCentralFlorida/UCF_Summer24/POOSD/swiPet/frontend/src/api.js"],"sourcesContent":["const bcrypt = require('bcrypt');\nconst { ObjectId } = require('mongodb');\nrequire('mongodb');\nrequire('express');\n\nexports.setApp = function (app, client) {\n\n    // Put database name here, so can use to specify\n    // database to be used\n    const dbName = 'swiPet';\n\n    // Modified login api\n    app.post('/api/login', async (req, res, next) => {\n        // incoming: login, password\n        // outgoing: id, firstName, lastName, error\n\n        // Need to initialize ret outside of\n        // conditional statements...\n        let ret = {};\n\n        let message = '';\n\n        const { login, password } = req.body;\n\n        // Same dbName here\n        const db = client.db(dbName);\n        const user = await db.collection('User').findOne({ Login: login });\n\n        // A user's login is found\n        if (user) {\n            const passwordMatch = await bcrypt.compare(password, user.Password);\n\n            // Password matches\n            if (passwordMatch) {\n                ret = { id: user._id, firstName: user.FirstName, lastName: user.LastName, message: message };\n            }\n\n            // Password doesn't match\n            else {\n                message = \"Invalid credentials\";\n                ret = { message: message };\n            }\n        }\n        // User's login not found\n        else {\n            message = \"User not found\";\n            ret = { message: message };\n        }\n\n        res.status(200).json(ret);\n    });\n\n\n    // Delete user api; should delete user from database...\n    app.post(\"/api/deleteUser\", async (req, res, next) => {\n        // incoming: login, password\n        // outgoing: message\n\n        let message = \"\";\n\n        const { login, password } = req.body;\n\n        const db = client.db(dbName);\n\n        try {\n            // Search for user\n            // Since hashing password, search for login only\n            // password will be checked later\n            const user = await db.collection(\"User\").findOne({ Login: login });\n\n            // If user is found... cast delete user!\n            if (user) {\n                // Compare password and hashed password in database\n                const passwordMatch = bcrypt.compare(password, user.Password);\n\n                // If passwords match... cast delete\n                if (passwordMatch) {\n                    const result = db.collection(\"User\").deleteOne({ _id: user._id });\n                    message = \"User deleted\";\n                }\n\n                else {\n                    message = \"Incorrect credentials\";\n                }\n            }\n            else {\n                message = \"User not found\";\n            }\n        } catch (e) {\n            message = e.toString();\n        }\n\n        let ret = { message: message };\n        res.status(200).json(ret);\n    });\n\n    // Update user api - not including password\n    app.post(\"/api/updateUser\", async (req, res, next) => {\n        // incoming: login, firstName, lastName, email, phoneNumber, location\n        // outgoing: (new/same - firstName, lastName, email, phoneNumber, location), message\n        const { login, firstName, lastName, email, phoneNumber, location } = req.body;\n\n        let message = '';\n\n        const db = client.db(dbName);\n        const collection = db.collection('User');\n\n        let user = await collection.findOne({ Login: login });\n\n        // Check to see if valid user\n        if (user) {\n\n            let updatedUser = { FirstName: firstName, LastName: lastName, Email: email, PhoneNumber: phoneNumber, Location: location };\n\n            // Trim empty fields from updatedUser\n            // Done by stringify, which does not stringify\n            // undefined data, and parsing back to json\n            updatedUser = JSON.parse(JSON.stringify(updatedUser));\n\n\n            try {\n                // updateOne (filter, update)\n                // Filter based off login\n                const result = await collection.updateOne(\n                    // Case sensitive; Login: login,\n                    // not login: login\n                    { Login: login },\n                    { $set: updatedUser }\n                )\n\n                // Check to see if anything was updated\n                if (result.modifiedCount === 0) {\n                    message = \"No changes made to user\";\n                }\n                else {\n                    message = \"User updated successfully\";\n                }\n\n            } catch (e) {\n                message = e.toString();\n            }\n\n        }\n        else {\n            message = \"User not found\";\n        }\n\n        let ret = { message: message };\n        res.status(200).json(ret);\n    });\n\n    // Forgot password api\n    app.post(\"/api/forgotPassword\", async (req, res, next) => {\n\n    });\n\n    // Register api\n    // Need to implement password hashing via bcrypt - to do\n    app.post(\"/api/register\", async (req, res, next) => {\n        // incoming: firstName, lastName, login, password\n        // outgoing: id, firstName, lastName, email, message\n        const { firstName, lastName, email, phoneNumber, location, login, password } = req.body;\n        let message = '';\n        let id = -1;\n\n        // Forgot to add connection...\n        const db = client.db(dbName);\n\n        // try-catch to see if user exists or not\n        // if not, make new user\n        try {\n            // findOne finds one instance, which there should only be one\n            // instance of a login anyways\n            const existingUser = await db.collection('User').findOne({ Login: login });\n\n            // If user is found, don't do anything\n            if (existingUser) {\n                message = \"User already exists...\"\n            }\n            else {\n\n                //== bCrypt stuff... ==\n                // Essentially determines how long is spent\n                // on hashing password; higher is better, but\n                // takes longer to hash\n                const saltRounds = 12;\n                // Hash call\n                const hashedPassword = await bcrypt.hash(password, saltRounds);\n                //== End of bCrypt stuff... ==\n\n                // No user with login found, so make new user\n                const newUser = {\n                    FirstName: firstName,\n                    LastName: lastName,\n                    Email: email,\n                    PhoneNumber: phoneNumber,\n                    Location: location,\n                    Login: login,\n                    Password: hashedPassword,\n                    Favorites: {},\n                    Listings: {}\n                };\n\n                const result = await db.collection('User').insertOne(newUser);\n                id = result.insertedId;\n            }\n\n        } catch (e) {\n            message = e.toString();\n        }\n\n        // probably dont want  to return login and password here...\n        let ret = { id: id, firstName: firstName, lastName: lastName, email: email, message: message }\n        res.status(200).json(ret);\n    });\n\n    // API to add new pets to specific users and update their listings to reflect the new pet\n    app.post('/api/addpet', async (req, res) => {\n\n        // incoming: userLogin, petName, type, petAge, petGender, breed, petSize, bio, contactEmail, location, images\n        // outgoing: message, petId\n\n        const { userLogin, petName, type, petAge, petGender, breed, petSize, bio, contactEmail, location, images } = req.body;\n        let message = '';\n        let petId = null;\n        try {\n            // Connect to database\n            const db = client.db(dbName);\n\n            // Checks if there is a valid user to create the pet, if there is then create the pet\n            const user = await db.collection('User').findOne({ Login: userLogin });\n            if (user) {\n                const newPet = {\n                    Login: userLogin,\n                    Pet_Name: petName,\n                    Pet_Type: type,\n                    Age: petAge,\n                    Gender: petGender,\n                    Breed: breed,\n                    Size: petSize,\n                    Bio: bio,\n                    Contact_Email: contactEmail,\n                    Location: location,\n                    Images: images || []\n                };\n                // Insert new pet and their descriptions into database\n                const result = await db.collection('Pet').insertOne(newPet);\n\n                // Needed to get the pet's ObjectId\n                petId = result.insertedId;\n\n                // Updates Listing of user who created the pet with the pet's ObjectId\n                await db.collection('User').updateOne(\n                    { Login: userLogin },\n                    { $push: { Listings: petId } }\n                );\n                message = \"Pet Created\";\n            } else {\n                message = \"User does not exist\";\n            }\n        } catch (e) {\n            message = e.toString();\n        }\n        const ret = { message: message, petId: petId };\n        res.status(200).json(ret);\n    });\n\n    // API to add a pet to a user's favorites list\n    app.post('/api/addfavorite', async (req, res) => {\n\n        // incoming: userLogin, petId\n        // outgoing: message\n\n        const { userLogin, petId } = req.body;\n        let message = '';\n        try {\n            // Connect to the database\n            const db = client.db(dbName);\n\n            // Checks if there is a valid user\n            const user = await db.collection('User').findOne({ Login: userLogin });\n            if (user) {\n                const objectId = new ObjectId(petId);\n\n                // Check if there is a valid pet as well\n                const pet = await db.collection('Pet').findOne({ _id: objectId });\n\n                // If there is a valid user and a valid pet, add that pet to the user's favorited pets\n                if (pet) {\n                    await db.collection('User').updateOne(\n                        { Login: userLogin },\n                        { $addToSet: { Favorites: objectId } }\n                    );\n                    message = \"Pet added to favorites\";\n                } else {\n                    message = \"Pet not found\";\n                }\n            } else {\n                message = \"User does not exist\";\n            }\n        } catch (e) {\n            message = e.toString();\n        }\n        const ret = { message: message };\n        res.status(200).json(ret);\n    });\n\n    // API to delete a pet and the listing of the original user who uploaded the pet (as well as from the favorites list of anyone who has that pet favorited)\n    app.post('/api/deletepet', async (req, res) => {\n\n        // incoming: userLogin, petId\n        // outgoing: message\n\n        const { userLogin, petId } = req.body;\n        let message = '';\n        try {\n            // Connect to database\n            const db = client.db(dbName);\n            const user = await db.collection('User').findOne({ Login: userLogin });\n\n            // If there is a valid user, proceed to see if the pet is in the database\n            if (user) {\n                const objectId = new ObjectId(petId);\n                const pet = await db.collection('Pet').findOne({ _id: objectId });\n\n                // If the pet is in the database, proceed with deletion\n                if (pet) {\n\n                    // If the user that created the pet does not matche with the user that was inputted, return error\n                    if (pet.Login !== userLogin) {\n                        message = \"You do not have permission to delete this pet\";\n                    } else {\n                        // Delete from the pet collection\n                        await db.collection('Pet').deleteOne({ _id: pet._id });\n\n                        // Update the creator's listings to remove it\n                        await db.collection('User').updateOne(\n                            { Login: userLogin },\n                            { $pull: { Listings: pet._id } }\n                        );\n\n                        // Update all favorite's lists in all users so that it reflects that the pet was deleted\n                        await db.collection('User').updateMany(\n                            { Favorites: pet._id },\n                            { $pull: { Favorites: pet._id } }\n                        );\n                        message = \"Pet deleted successfully and removed from all favorites\";\n                    }\n                } else {\n                    message = \"Pet not found\";\n                }\n            } else {\n                message = \"User does not exist\";\n            }\n        } catch (e) {\n            message = e.toString();\n        }\n        const ret = { message: message };\n        res.status(200).json(ret);\n    });\n\n}"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAM;EAAEC;AAAS,CAAC,GAAGD,OAAO,CAAC,SAAS,CAAC;AACvCA,OAAO,CAAC,SAAS,CAAC;AAClBA,OAAO,CAAC,SAAS,CAAC;AAElBE,OAAO,CAACC,MAAM,GAAG,UAAUC,GAAG,EAAEC,MAAM,EAAE;EAEpC;EACA;EACA,MAAMC,MAAM,GAAG,QAAQ;;EAEvB;EACAF,GAAG,CAACG,IAAI,CAAC,YAAY,EAAE,OAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;IAC7C;IACA;;IAEA;IACA;IACA,IAAIC,GAAG,GAAG,CAAC,CAAC;IAEZ,IAAIC,OAAO,GAAG,EAAE;IAEhB,MAAM;MAAEC,KAAK;MAAEC;IAAS,CAAC,GAAGN,GAAG,CAACO,IAAI;;IAEpC;IACA,MAAMC,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;IAC5B,MAAMW,IAAI,GAAG,MAAMD,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACC,OAAO,CAAC;MAAEC,KAAK,EAAEP;IAAM,CAAC,CAAC;;IAElE;IACA,IAAII,IAAI,EAAE;MACN,MAAMI,aAAa,GAAG,MAAMtB,MAAM,CAACuB,OAAO,CAACR,QAAQ,EAAEG,IAAI,CAACM,QAAQ,CAAC;;MAEnE;MACA,IAAIF,aAAa,EAAE;QACfV,GAAG,GAAG;UAAEa,EAAE,EAAEP,IAAI,CAACQ,GAAG;UAAEC,SAAS,EAAET,IAAI,CAACU,SAAS;UAAEC,QAAQ,EAAEX,IAAI,CAACY,QAAQ;UAAEjB,OAAO,EAAEA;QAAQ,CAAC;MAChG;;MAEA;MAAA,KACK;QACDA,OAAO,GAAG,qBAAqB;QAC/BD,GAAG,GAAG;UAAEC,OAAO,EAAEA;QAAQ,CAAC;MAC9B;IACJ;IACA;IAAA,KACK;MACDA,OAAO,GAAG,gBAAgB;MAC1BD,GAAG,GAAG;QAAEC,OAAO,EAAEA;MAAQ,CAAC;IAC9B;IAEAH,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;;EAGF;EACAP,GAAG,CAACG,IAAI,CAAC,iBAAiB,EAAE,OAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;IAClD;IACA;;IAEA,IAAIE,OAAO,GAAG,EAAE;IAEhB,MAAM;MAAEC,KAAK;MAAEC;IAAS,CAAC,GAAGN,GAAG,CAACO,IAAI;IAEpC,MAAMC,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;IAE5B,IAAI;MACA;MACA;MACA;MACA,MAAMW,IAAI,GAAG,MAAMD,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACC,OAAO,CAAC;QAAEC,KAAK,EAAEP;MAAM,CAAC,CAAC;;MAElE;MACA,IAAII,IAAI,EAAE;QACN;QACA,MAAMI,aAAa,GAAGtB,MAAM,CAACuB,OAAO,CAACR,QAAQ,EAAEG,IAAI,CAACM,QAAQ,CAAC;;QAE7D;QACA,IAAIF,aAAa,EAAE;UACf,MAAMW,MAAM,GAAGhB,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACe,SAAS,CAAC;YAAER,GAAG,EAAER,IAAI,CAACQ;UAAI,CAAC,CAAC;UACjEb,OAAO,GAAG,cAAc;QAC5B,CAAC,MAEI;UACDA,OAAO,GAAG,uBAAuB;QACrC;MACJ,CAAC,MACI;QACDA,OAAO,GAAG,gBAAgB;MAC9B;IACJ,CAAC,CAAC,OAAOsB,CAAC,EAAE;MACRtB,OAAO,GAAGsB,CAAC,CAACC,QAAQ,CAAC,CAAC;IAC1B;IAEA,IAAIxB,GAAG,GAAG;MAAEC,OAAO,EAAEA;IAAQ,CAAC;IAC9BH,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;;EAEF;EACAP,GAAG,CAACG,IAAI,CAAC,iBAAiB,EAAE,OAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;IAClD;IACA;IACA,MAAM;MAAEG,KAAK;MAAEa,SAAS;MAAEE,QAAQ;MAAEQ,KAAK;MAAEC,WAAW;MAAEC;IAAS,CAAC,GAAG9B,GAAG,CAACO,IAAI;IAE7E,IAAIH,OAAO,GAAG,EAAE;IAEhB,MAAMI,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;IAC5B,MAAMY,UAAU,GAAGF,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC;IAExC,IAAID,IAAI,GAAG,MAAMC,UAAU,CAACC,OAAO,CAAC;MAAEC,KAAK,EAAEP;IAAM,CAAC,CAAC;;IAErD;IACA,IAAII,IAAI,EAAE;MAEN,IAAIsB,WAAW,GAAG;QAAEZ,SAAS,EAAED,SAAS;QAAEG,QAAQ,EAAED,QAAQ;QAAEY,KAAK,EAAEJ,KAAK;QAAEK,WAAW,EAAEJ,WAAW;QAAEK,QAAQ,EAAEJ;MAAS,CAAC;;MAE1H;MACA;MACA;MACAC,WAAW,GAAGI,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACN,WAAW,CAAC,CAAC;MAGrD,IAAI;QACA;QACA;QACA,MAAMP,MAAM,GAAG,MAAMd,UAAU,CAAC4B,SAAS;QACrC;QACA;QACA;UAAE1B,KAAK,EAAEP;QAAM,CAAC,EAChB;UAAEkC,IAAI,EAAER;QAAY,CACxB,CAAC;;QAED;QACA,IAAIP,MAAM,CAACgB,aAAa,KAAK,CAAC,EAAE;UAC5BpC,OAAO,GAAG,yBAAyB;QACvC,CAAC,MACI;UACDA,OAAO,GAAG,2BAA2B;QACzC;MAEJ,CAAC,CAAC,OAAOsB,CAAC,EAAE;QACRtB,OAAO,GAAGsB,CAAC,CAACC,QAAQ,CAAC,CAAC;MAC1B;IAEJ,CAAC,MACI;MACDvB,OAAO,GAAG,gBAAgB;IAC9B;IAEA,IAAID,GAAG,GAAG;MAAEC,OAAO,EAAEA;IAAQ,CAAC;IAC9BH,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;;EAEF;EACAP,GAAG,CAACG,IAAI,CAAC,qBAAqB,EAAE,OAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK,CAE1D,CAAC,CAAC;;EAEF;EACA;EACAN,GAAG,CAACG,IAAI,CAAC,eAAe,EAAE,OAAOC,GAAG,EAAEC,GAAG,EAAEC,IAAI,KAAK;IAChD;IACA;IACA,MAAM;MAAEgB,SAAS;MAAEE,QAAQ;MAAEQ,KAAK;MAAEC,WAAW;MAAEC,QAAQ;MAAEzB,KAAK;MAAEC;IAAS,CAAC,GAAGN,GAAG,CAACO,IAAI;IACvF,IAAIH,OAAO,GAAG,EAAE;IAChB,IAAIY,EAAE,GAAG,CAAC,CAAC;;IAEX;IACA,MAAMR,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;;IAE5B;IACA;IACA,IAAI;MACA;MACA;MACA,MAAM2C,YAAY,GAAG,MAAMjC,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACC,OAAO,CAAC;QAAEC,KAAK,EAAEP;MAAM,CAAC,CAAC;;MAE1E;MACA,IAAIoC,YAAY,EAAE;QACdrC,OAAO,GAAG,wBAAwB;MACtC,CAAC,MACI;QAED;QACA;QACA;QACA;QACA,MAAMsC,UAAU,GAAG,EAAE;QACrB;QACA,MAAMC,cAAc,GAAG,MAAMpD,MAAM,CAACqD,IAAI,CAACtC,QAAQ,EAAEoC,UAAU,CAAC;QAC9D;;QAEA;QACA,MAAMG,OAAO,GAAG;UACZ1B,SAAS,EAAED,SAAS;UACpBG,QAAQ,EAAED,QAAQ;UAClBY,KAAK,EAAEJ,KAAK;UACZK,WAAW,EAAEJ,WAAW;UACxBK,QAAQ,EAAEJ,QAAQ;UAClBlB,KAAK,EAAEP,KAAK;UACZU,QAAQ,EAAE4B,cAAc;UACxBG,SAAS,EAAE,CAAC,CAAC;UACbC,QAAQ,EAAE,CAAC;QACf,CAAC;QAED,MAAMvB,MAAM,GAAG,MAAMhB,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACsC,SAAS,CAACH,OAAO,CAAC;QAC7D7B,EAAE,GAAGQ,MAAM,CAACyB,UAAU;MAC1B;IAEJ,CAAC,CAAC,OAAOvB,CAAC,EAAE;MACRtB,OAAO,GAAGsB,CAAC,CAACC,QAAQ,CAAC,CAAC;IAC1B;;IAEA;IACA,IAAIxB,GAAG,GAAG;MAAEa,EAAE,EAAEA,EAAE;MAAEE,SAAS,EAAEA,SAAS;MAAEE,QAAQ,EAAEA,QAAQ;MAAEQ,KAAK,EAAEA,KAAK;MAAExB,OAAO,EAAEA;IAAQ,CAAC;IAC9FH,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;;EAEF;EACAP,GAAG,CAACG,IAAI,CAAC,aAAa,EAAE,OAAOC,GAAG,EAAEC,GAAG,KAAK;IAExC;IACA;;IAEA,MAAM;MAAEiD,SAAS;MAAEC,OAAO;MAAEC,IAAI;MAAEC,MAAM;MAAEC,SAAS;MAAEC,KAAK;MAAEC,OAAO;MAAEC,GAAG;MAAEC,YAAY;MAAE5B,QAAQ;MAAE6B;IAAO,CAAC,GAAG3D,GAAG,CAACO,IAAI;IACrH,IAAIH,OAAO,GAAG,EAAE;IAChB,IAAIwD,KAAK,GAAG,IAAI;IAChB,IAAI;MACA;MACA,MAAMpD,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;;MAE5B;MACA,MAAMW,IAAI,GAAG,MAAMD,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACC,OAAO,CAAC;QAAEC,KAAK,EAAEsC;MAAU,CAAC,CAAC;MACtE,IAAIzC,IAAI,EAAE;QACN,MAAMoD,MAAM,GAAG;UACXjD,KAAK,EAAEsC,SAAS;UAChBY,QAAQ,EAAEX,OAAO;UACjBY,QAAQ,EAAEX,IAAI;UACdY,GAAG,EAAEX,MAAM;UACXY,MAAM,EAAEX,SAAS;UACjBY,KAAK,EAAEX,KAAK;UACZY,IAAI,EAAEX,OAAO;UACbY,GAAG,EAAEX,GAAG;UACRY,aAAa,EAAEX,YAAY;UAC3BxB,QAAQ,EAAEJ,QAAQ;UAClBwC,MAAM,EAAEX,MAAM,IAAI;QACtB,CAAC;QACD;QACA,MAAMnC,MAAM,GAAG,MAAMhB,EAAE,CAACE,UAAU,CAAC,KAAK,CAAC,CAACsC,SAAS,CAACa,MAAM,CAAC;;QAE3D;QACAD,KAAK,GAAGpC,MAAM,CAACyB,UAAU;;QAEzB;QACA,MAAMzC,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAAC4B,SAAS,CACjC;UAAE1B,KAAK,EAAEsC;QAAU,CAAC,EACpB;UAAEqB,KAAK,EAAE;YAAExB,QAAQ,EAAEa;UAAM;QAAE,CACjC,CAAC;QACDxD,OAAO,GAAG,aAAa;MAC3B,CAAC,MAAM;QACHA,OAAO,GAAG,qBAAqB;MACnC;IACJ,CAAC,CAAC,OAAOsB,CAAC,EAAE;MACRtB,OAAO,GAAGsB,CAAC,CAACC,QAAQ,CAAC,CAAC;IAC1B;IACA,MAAMxB,GAAG,GAAG;MAAEC,OAAO,EAAEA,OAAO;MAAEwD,KAAK,EAAEA;IAAM,CAAC;IAC9C3D,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;;EAEF;EACAP,GAAG,CAACG,IAAI,CAAC,kBAAkB,EAAE,OAAOC,GAAG,EAAEC,GAAG,KAAK;IAE7C;IACA;;IAEA,MAAM;MAAEiD,SAAS;MAAEU;IAAM,CAAC,GAAG5D,GAAG,CAACO,IAAI;IACrC,IAAIH,OAAO,GAAG,EAAE;IAChB,IAAI;MACA;MACA,MAAMI,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;;MAE5B;MACA,MAAMW,IAAI,GAAG,MAAMD,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACC,OAAO,CAAC;QAAEC,KAAK,EAAEsC;MAAU,CAAC,CAAC;MACtE,IAAIzC,IAAI,EAAE;QACN,MAAM+D,QAAQ,GAAG,IAAI/E,QAAQ,CAACmE,KAAK,CAAC;;QAEpC;QACA,MAAMa,GAAG,GAAG,MAAMjE,EAAE,CAACE,UAAU,CAAC,KAAK,CAAC,CAACC,OAAO,CAAC;UAAEM,GAAG,EAAEuD;QAAS,CAAC,CAAC;;QAEjE;QACA,IAAIC,GAAG,EAAE;UACL,MAAMjE,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAAC4B,SAAS,CACjC;YAAE1B,KAAK,EAAEsC;UAAU,CAAC,EACpB;YAAEwB,SAAS,EAAE;cAAE5B,SAAS,EAAE0B;YAAS;UAAE,CACzC,CAAC;UACDpE,OAAO,GAAG,wBAAwB;QACtC,CAAC,MAAM;UACHA,OAAO,GAAG,eAAe;QAC7B;MACJ,CAAC,MAAM;QACHA,OAAO,GAAG,qBAAqB;MACnC;IACJ,CAAC,CAAC,OAAOsB,CAAC,EAAE;MACRtB,OAAO,GAAGsB,CAAC,CAACC,QAAQ,CAAC,CAAC;IAC1B;IACA,MAAMxB,GAAG,GAAG;MAAEC,OAAO,EAAEA;IAAQ,CAAC;IAChCH,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;;EAEF;EACAP,GAAG,CAACG,IAAI,CAAC,gBAAgB,EAAE,OAAOC,GAAG,EAAEC,GAAG,KAAK;IAE3C;IACA;;IAEA,MAAM;MAAEiD,SAAS;MAAEU;IAAM,CAAC,GAAG5D,GAAG,CAACO,IAAI;IACrC,IAAIH,OAAO,GAAG,EAAE;IAChB,IAAI;MACA;MACA,MAAMI,EAAE,GAAGX,MAAM,CAACW,EAAE,CAACV,MAAM,CAAC;MAC5B,MAAMW,IAAI,GAAG,MAAMD,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACC,OAAO,CAAC;QAAEC,KAAK,EAAEsC;MAAU,CAAC,CAAC;;MAEtE;MACA,IAAIzC,IAAI,EAAE;QACN,MAAM+D,QAAQ,GAAG,IAAI/E,QAAQ,CAACmE,KAAK,CAAC;QACpC,MAAMa,GAAG,GAAG,MAAMjE,EAAE,CAACE,UAAU,CAAC,KAAK,CAAC,CAACC,OAAO,CAAC;UAAEM,GAAG,EAAEuD;QAAS,CAAC,CAAC;;QAEjE;QACA,IAAIC,GAAG,EAAE;UAEL;UACA,IAAIA,GAAG,CAAC7D,KAAK,KAAKsC,SAAS,EAAE;YACzB9C,OAAO,GAAG,+CAA+C;UAC7D,CAAC,MAAM;YACH;YACA,MAAMI,EAAE,CAACE,UAAU,CAAC,KAAK,CAAC,CAACe,SAAS,CAAC;cAAER,GAAG,EAAEwD,GAAG,CAACxD;YAAI,CAAC,CAAC;;YAEtD;YACA,MAAMT,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAAC4B,SAAS,CACjC;cAAE1B,KAAK,EAAEsC;YAAU,CAAC,EACpB;cAAEyB,KAAK,EAAE;gBAAE5B,QAAQ,EAAE0B,GAAG,CAACxD;cAAI;YAAE,CACnC,CAAC;;YAED;YACA,MAAMT,EAAE,CAACE,UAAU,CAAC,MAAM,CAAC,CAACkE,UAAU,CAClC;cAAE9B,SAAS,EAAE2B,GAAG,CAACxD;YAAI,CAAC,EACtB;cAAE0D,KAAK,EAAE;gBAAE7B,SAAS,EAAE2B,GAAG,CAACxD;cAAI;YAAE,CACpC,CAAC;YACDb,OAAO,GAAG,yDAAyD;UACvE;QACJ,CAAC,MAAM;UACHA,OAAO,GAAG,eAAe;QAC7B;MACJ,CAAC,MAAM;QACHA,OAAO,GAAG,qBAAqB;MACnC;IACJ,CAAC,CAAC,OAAOsB,CAAC,EAAE;MACRtB,OAAO,GAAGsB,CAAC,CAACC,QAAQ,CAAC,CAAC;IAC1B;IACA,MAAMxB,GAAG,GAAG;MAAEC,OAAO,EAAEA;IAAQ,CAAC;IAChCH,GAAG,CAACqB,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAACpB,GAAG,CAAC;EAC7B,CAAC,CAAC;AAEN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}